{"meta":{"title":"一叶扁舟","subtitle":"","description":"闲着没事，随便写写。随便看看即可，对内容正确性、真实性不能保证。","author":"安可","url":"https://casuallc.github.io","root":"/"},"pages":[{"title":"","date":"2024-02-07T06:37:20.678Z","updated":"2024-02-07T06:37:20.678Z","comments":true,"path":"404.html","permalink":"https://casuallc.github.io/404.html","excerpt":"","text":""},{"title":"个人介绍","date":"2023-04-06T11:43:22.066Z","updated":"2023-04-06T11:43:22.066Z","comments":true,"path":"about/index.html","permalink":"https://casuallc.github.io/about/index.html","excerpt":"","text":"地点：深圳职业：程序员Github：https://github.com/casuallcWeixin：waiting2092"},{"title":"推荐网站","date":"2023-04-05T09:57:07.763Z","updated":"2023-04-05T09:57:07.763Z","comments":true,"path":"friends/index.html","permalink":"https://casuallc.github.io/friends/index.html","excerpt":"","text":"www.google.com"},{"title":"","date":"2023-04-05T10:09:53.723Z","updated":"2023-04-05T10:09:53.723Z","comments":true,"path":"mylist/index.html","permalink":"https://casuallc.github.io/mylist/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2024-02-07T03:57:18.752Z","updated":"2024-02-07T03:57:18.752Z","comments":true,"path":"categories/index.html","permalink":"https://casuallc.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2024-02-07T03:57:10.452Z","updated":"2024-02-07T03:57:10.452Z","comments":true,"path":"tags/index.html","permalink":"https://casuallc.github.io/tags/index.html","excerpt":"","text":""},{"title":"日程表","date":"2024-02-09T10:46:50.000Z","updated":"2024-02-18T06:16:58.520Z","comments":true,"path":"schedule/index.html","permalink":"https://casuallc.github.io/schedule/index.html","excerpt":"","text":""}],"posts":[{"title":"rust 简单入门","slug":"rust-简单入门","date":"2024-02-19T06:39:35.000Z","updated":"2024-02-19T06:39:35.000Z","comments":true,"path":"2024/02/19/rust-简单入门/","permalink":"https://casuallc.github.io/2024/02/19/rust-%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/","excerpt":"Rust 简介Rust 是由 Mozilla 主导开发的通用、编译型编程语言。设计准则为“安全、并发、实用”，支持函数式、并行式、过程式以及面向对象的程式设计风格。 Rust 是一种系统编程语言，通常用于构建快速可靠的软件，特别是在需要内存安全和线程安全至关重要的情况下，如操作系统、游戏引擎和Web浏览器。","text":"Rust 简介Rust 是由 Mozilla 主导开发的通用、编译型编程语言。设计准则为“安全、并发、实用”，支持函数式、并行式、过程式以及面向对象的程式设计风格。 Rust 是一种系统编程语言，通常用于构建快速可靠的软件，特别是在需要内存安全和线程安全至关重要的情况下，如操作系统、游戏引擎和Web浏览器。 Rust 的一些关键特性： 无 GC：Rust 通过其所有权系统实现内存安全，该系统确保有效地管理内存而无需垃圾收集器。 零成本抽象：Rust 允许使用高级抽象而不产生运行时开销，使得编写既安全又高效的代码成为可能。 高并发：Rust 的所有权模型和类型系统在编译时防止数据竞争，确保线程安全，使开发人员可以放心地编写并发代码。 Cargo 包管理器：Rust 配备了 Cargo，一个强大的包管理器和构建系统，简化了管理依赖项和构建项目的过程。 社区驱动的开发：Rust 拥有一个充满活力和积极的社区，为其开发、文档和生态系统做出贡献。 简答使用 参考：https://doc.rust-lang.org/book/title-page.html 安装（windows）到 Rust 官网 下载 Rust 安装器安装即可（可能需要先安装 Visual Studio）。 安装后打开 PowerShell 执行 rustc –version，如下： 123PS C:\\Users\\casua&gt; rustc --versionrustc 1.75.0 (82e1608df 2023-12-21)PS C:\\Users\\casua&gt; 有如上输出则证明安装成功，下面就可以编写测试代码进行功能测试了。 Hello World和其他编程语言一样，从 Hello World 开始了解 Rust。 首先我们需要创建一个文件夹： 1mkdir rust-test 然后创建 main.rs 文件，并写入如下代码： 123fn main() &#123; println!(&quot;Hello World&quot;);&#125; 编译成可执行文件： 1powershell 编译成功后会生成 main.exe 和 main.pbd 文件，exe 是可执行文件，pbd 是包含调试信息的中间文件。 1234567891011PS E:\\rust-test&gt; ls 目录: E:\\rust-testMode LastWriteTime Length Name---- ------------- ------ -----a---- 2024/2/19 15:12 148480 main.exe-a---- 2024/2/19 15:12 1339392 main.pdb-a---- 2024/2/19 15:11 42 main.rs 执行： 123PS E:\\rust-test&gt; ./mainHello WorldPS E:\\rust-test&gt; 至此，我们第一个 rust 程序运行成功了。 包管理工具 Cargo用 rustc 只能编译单个文件，如果是一个比较大的项目则需要使用 Cargo，Cargo 是一个包管理工具，可以管理和编译多个 Rust 文件。 Cargo 在安装 Rust 时已经默认安装了，所以我们可以直接使用。 首先创建一个工程： 1234567891011121314151617PS E:\\rust-test&gt; cargo new hello Created binary (application) `hello` packagePS E:\\rust-test&gt; cd .\\hello\\PS E:\\rust-test\\hello&gt; ls 目录: E:\\rust-test\\helloMode LastWriteTime Length Name---- ------------- ------ ----d----- 2024/2/19 15:24 src-a---- 2024/2/19 15:24 8 .gitignore-a---- 2024/2/19 15:24 174 Cargo.tomlPS E:\\rust-test\\hello&gt; 创建成功后会生成 Cargo.toml 文件，文件中记录了项目信息，包含版本、依赖等内容，如下： 12345678[package]name = &quot;hello&quot;version = &quot;0.1.0&quot;edition = &quot;2021&quot;# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html[dependencies] 然后我们在 src 目录创建 main.rs，加上刚才测试的代码并使用 cargo 构建： 1234PS E:\\rust-test\\hello&gt; cargo build Compiling hello v0.1.0 (E:\\rust-test\\hello) Finished dev [unoptimized + debuginfo] target(s) in 0.51sPS E:\\rust-test\\hello&gt; 构建成功后在 target&#x2F;debug 目录可以看到可执行文件 hello.exe： 123PS E:\\rust-test\\hello&gt; .\\target\\debug\\hello.exeHello WorldPS E:\\rust-test\\hello&gt; 我们还可以直接使用 cargo run 执行代码： 12345PS E:\\rust-test\\hello&gt; cargo run Finished dev [unoptimized + debuginfo] target(s) in 0.00s Running `target\\debug\\hello.exe`Hello WorldPS E:\\rust-test\\hello&gt; 所有权Rust 没有垃圾回收，也不用像 C&#x2F;C++ 那样手动申请内存、释放内存。在 Rust 中，每个值在某个时刻都有唯一一个所有者，所有者发生改变后，该值就不能再次使用。 Rust 中每个值都有一个 owner。 同一时刻只能有一个 owner。 当离开 owner 范围后，该值不能再次使用。 方法调用举例如下： 123456789101112fn main() &#123; let param = String::from(&quot;hello&quot;); owner_change(param); println!(&quot;value: &#123;&#125;&quot;, param); // 报错；param 的所有权已经转移到其他地方，因此这里不能再次使用了&#125;fn owner_change(v: String) &#123; println!(&quot;value in method: &#123;&#125;&quot;, v);&#125; 123456789101112131415161718192021222324252627282930PS E:\\rust-test\\hello&gt; cargo run Compiling hello v0.1.0 (E:\\rust-test\\hello)error[E0382]: borrow of moved value: `param` --&gt; src\\main.rs:5:25 |2 | let param = String::from(&quot;hello&quot;); | ----- move occurs because `param` has type `String`, which does not implement the `Copy` trait3 | owner_change(param); | ----- value moved here4 |5 | println!(&quot;value: &#123;&#125;&quot;, param); // 报错；param 的所有权已经转移到其他地方，因此这里不能再次使用了 ... | ^^^^^ value borrowed here after move |note: consider changing this parameter type in function `owner_change` to borrow instead if owning the value isn&#x27;t necessary --&gt; src\\main.rs:9:20 |9 | fn owner_change(v: String) &#123; | ------------ ^^^^^^ this parameter takes ownership of the value | | | in this function = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)help: consider cloning the value if the performance cost is acceptable |3 | owner_change(param.clone()); | ++++++++For more information about this error, try `rustc --explain E0382`.error: could not compile `hello` (bin &quot;hello&quot;) due to previous errorPS E:\\rust-test\\hello&gt; 但我们可以在方法执行完再次获取到所有权，如下： 1234567891011fn main() &#123; let param = String::from(&quot;hello&quot;); let param = owner_change(param); println!(&quot;value: &#123;&#125;&quot;, param); // 正常输出&#125;fn owner_change(v: String) -&gt; String &#123; println!(&quot;value in method: &#123;&#125;&quot;, v); v&#125; 变量传递同样，如果一个变量赋予另外一个变量，则之前的变量不能再次使用，如下： 12345fn main() &#123; let s1 = String::from(&quot;hello&quot;); let s2 = s1; println(&quot;s1: &#123;&#125;, s2: &#123;&#125;&quot;, s1, s2); // 报错&#125; 123456789101112131415161718192021PS E:\\rust-test\\hello&gt; cargo run Compiling hello v0.1.0 (E:\\rust-test\\hello)error[E0382]: borrow of moved value: `s1` --&gt; src\\main.rs:4:30 |2 | let s1 = String::from(&quot;hello&quot;); | -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait3 | let s2 = s1; | -- value moved here4 | println!(&quot;s1: &#123;&#125;, s2: &#123;&#125;&quot;, s1, s2); | ^^ value borrowed here after move | = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)help: consider cloning the value if the performance cost is acceptable |3 | let s2 = s1.clone(); | ++++++++For more information about this error, try `rustc --explain E0382`.error: could not compile `hello` (bin &quot;hello&quot;) due to previous errorPS E:\\rust-test\\hello&gt; 传递地址在方法中传递引用所有权会发生改变，传递地址所有权不会发生改变，因此如下代码可以正常运行： 123456789101112fn main() &#123; let param = String::from(&quot;hello&quot;); let len = owner_change(&amp;param); println!(&quot;value: &#123;&#125;, len: &#123;&#125;&quot;, param, len);&#125;fn owner_change(v: &amp;String) -&gt; usize &#123; println!(&quot;value in method: &#123;&#125;&quot;, v); v.len() // 非分号结尾表示返回值&#125; 运行结果如下： 1234567PS E:\\rust-test\\hello&gt; cargo run Compiling hello v0.1.0 (E:\\rust-test\\hello) Finished dev [unoptimized + debuginfo] target(s) in 0.29s Running `target\\debug\\hello.exe`value in method: hellovalue: hello, len: 5PS E:\\rust-test\\hello&gt; 最后上面体验了下 Rust 的基本用法，主要是所有权这块。Rust 在编译时强制用户按照约定的规则编写代码，增加了代码编写难度。一旦编译成功，则基本不可能出现内存泄漏问题。","categories":[{"name":"2024","slug":"2024","permalink":"https://casuallc.github.io/categories/2024/"}],"tags":[],"author":"changqing"},{"title":"番茄土豆肥牛","slug":"番茄土豆肥牛","date":"2024-02-14T05:30:01.000Z","updated":"2024-02-14T05:30:01.000Z","comments":true,"path":"2024/02/14/番茄土豆肥牛/","permalink":"https://casuallc.github.io/2024/02/14/%E7%95%AA%E8%8C%84%E5%9C%9F%E8%B1%86%E8%82%A5%E7%89%9B/","excerpt":"番茄土豆肥牛做法分享一道简单好吃的家常菜：番茄土豆肥牛。","text":"番茄土豆肥牛做法分享一道简单好吃的家常菜：番茄土豆肥牛。 材料准备主要是牛肉卷和番茄，其他都是看心情添加。我们是吃火锅剩了一些牛肉，所以第二天做了这道番茄肥牛，虽然看起来不怎么样，但吃起来还可以。需要准备的菜和调料如下： 番茄 土豆 牛肉卷 牛肉丸（可选） 金针菇 娃娃菜 小葱 盐 葱姜蒜 老抽 生抽 耗油 白醋 番茄酱 淀粉 土豆和番茄切丁，番茄需要先用开水去皮。 调汁万众放入适量盐、老抽、生抽、耗油、淀粉，加水搅拌均匀。 把牛肉、金针菇煮熟锅中烧水，先放入金针菇，几分钟后捞出备用。 然后放入土豆，煮熟后捞出。 最后放入牛肉和牛肉丸，加入少许白醋去腥，等牛肉变色后捞出。 炒锅中烧油，加入葱姜蒜，炒出蒜香后加番茄翻炒，把番茄炒成番茄汁，然后加入刚才调好的酱汁，继续翻炒几下加入少许番茄酱提味。 然后加入适量水，水开后加入金针菇、土豆、牛肉和牛肉丸，煮几分钟等菜入味后装盘即可。","categories":[{"name":"2024","slug":"2024","permalink":"https://casuallc.github.io/categories/2024/"}],"tags":[{"name":"做菜","slug":"做菜","permalink":"https://casuallc.github.io/tags/%E5%81%9A%E8%8F%9C/"},{"name":"生活","slug":"生活","permalink":"https://casuallc.github.io/tags/%E7%94%9F%E6%B4%BB/"}],"author":"changqing"},{"title":"地三鲜家常做法","slug":"地三鲜家常做法","date":"2024-02-14T05:13:45.000Z","updated":"2024-02-14T05:13:45.000Z","comments":true,"path":"2024/02/14/地三鲜家常做法/","permalink":"https://casuallc.github.io/2024/02/14/%E5%9C%B0%E4%B8%89%E9%B2%9C%E5%AE%B6%E5%B8%B8%E5%81%9A%E6%B3%95/","excerpt":"地三鲜家常做法过年闲来无事，研究一些家常菜，也满足下自己的胃。 首先是地三鲜，这个相对来说很简单，而且材料只需要土豆、茄子和青椒。","text":"地三鲜家常做法过年闲来无事，研究一些家常菜，也满足下自己的胃。 首先是地三鲜，这个相对来说很简单，而且材料只需要土豆、茄子和青椒。 材料准备茄子、土豆切块，青椒用手撕成小块，然后茄子撒上淀粉，用手抓匀，确保每个茄子上都有一层淀粉。 调料 盐 生抽 老抽 鸡精 耗油 糖 葱姜蒜 玉米淀粉 准备料汁碗中添加盐、生抽、老抽、鸡精、糖、淀粉，加水拌匀。 油炸锅中烧油，六成热后放入土豆、青椒，土豆炸出金黄捞出。 继续放入茄子，变色后再炸一会捞出。 炒锅中油倒出，留一点准备炒菜。放入葱姜蒜，炒出蒜香。 然后加入炸后的土豆、青椒和茄子，用铲子炒一会后放入准备好的调料，继续翻炒一会即可装盘捞出。","categories":[{"name":"2024","slug":"2024","permalink":"https://casuallc.github.io/categories/2024/"}],"tags":[{"name":"做菜","slug":"做菜","permalink":"https://casuallc.github.io/tags/%E5%81%9A%E8%8F%9C/"},{"name":"生活","slug":"生活","permalink":"https://casuallc.github.io/tags/%E7%94%9F%E6%B4%BB/"}],"author":"changqing"},{"title":"基于 valine 和 leancloud 的评论系统","slug":"基于-valine-和-leancloud-的评论系统","date":"2024-02-08T06:36:48.000Z","updated":"2024-02-08T07:01:37.692Z","comments":true,"path":"2024/02/08/基于-valine-和-leancloud-的评论系统/","permalink":"https://casuallc.github.io/2024/02/08/%E5%9F%BA%E4%BA%8E-valine-%E5%92%8C-leancloud-%E7%9A%84%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/","excerpt":"评论系统基于 hexo next 主题搭建博客后，测试了几种评论系统，像畅言、Gitalk 等都需要登陆后才能评论，实际用起来比较繁琐，而且评论的人基于安全的考虑也不会授权第三方评论系统获得自己的账号授权。 试想，一个偶然发现的网站，一个没怎么听到过的系统，怎么会允许获取自己的账号授权呢。","text":"评论系统基于 hexo next 主题搭建博客后，测试了几种评论系统，像畅言、Gitalk 等都需要登陆后才能评论，实际用起来比较繁琐，而且评论的人基于安全的考虑也不会授权第三方评论系统获得自己的账号授权。 试想，一个偶然发现的网站，一个没怎么听到过的系统，怎么会允许获取自己的账号授权呢。 leancloud &amp; valineleancloud 是一个云计算平台，可以在上边创建应用，然后通过 http 或者其他方式调用平台对外提供的接口。最重要的是，平台提供的接口调用和存储功能都免费！！！ 而 valine 就是基于这一特性，在 hexo 主题中嵌入评论插件，用户提交评论时会发数据发送到 leancloud 对外开放的接口，从而实现保存评论信息。 而且，该插件不需要登录。这样评论本身就没有了限制，大家可以畅所欲言，比畅言更畅言。但这种方式对博主本身的安全性有一定的影响，比如恶意评论导致 leancloud 的接口频繁调用。 接入方式下面是以 NexT(7.8.0) 为例进行接入说明。 注册 leancloud登录 leancloud 注册账号。 注意一定要用国际版，国内版存在个人信息验证问题！！！ 注册成功并登录后，需要邮箱验证。 验证成功后就可以创建自己的应用了，在首页点击：Create App 选择开发者模式 创建完成过后点【设置】查看 app id 等信息。 图上标记的信息需要在下面 NexT 主题中配置。 配置 NexT在 _config.yml 中找到评论相关配置，设置评论方式为 valine，然后设置 app id 等信息 12345678910comments: # Choose a comment system to be displayed by default. # Available values: changyan | disqus | disqusjs | gitalk | livere | valine active: valinevaline: enable: true appid: xxxx # Your leancloud application appid appkey: xxxx # Your leancloud application appkey serverURLs: https://xxxx # 会往这个地址中发送数据 效果","categories":[{"name":"2024","slug":"2024","permalink":"https://casuallc.github.io/categories/2024/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://casuallc.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"工具","slug":"工具","permalink":"https://casuallc.github.io/tags/%E5%B7%A5%E5%85%B7/"}],"author":"changqing"},{"title":"Spring Bean 生命周期","slug":"Spring-Bean-生命周期","date":"2024-02-07T01:33:00.000Z","updated":"2024-02-08T04:11:55.537Z","comments":true,"path":"2024/02/07/Spring-Bean-生命周期/","permalink":"https://casuallc.github.io/2024/02/07/Spring-Bean-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"Spring Bean 生命周期spring 在初始化时会通过注解或者配置文件初始化所有的 bean，在初始化过程中支持执行自定义的逻辑，比如加载配置等。spring bean 的生命周期如下图所示：","text":"Spring Bean 生命周期spring 在初始化时会通过注解或者配置文件初始化所有的 bean，在初始化过程中支持执行自定义的逻辑，比如加载配置等。spring bean 的生命周期如下图所示： 其中 BeanPostProcessor 是对所有 Bean 进行拦截， InitializingBean 是对当前 Bean 进行拦截。所以如果需要在一个 Bean 初始化时做一些初始化的工作，则要实现 InitializingBean 接口。示例如下 1234567891011121314151617import org.springframework.beans.BeansException;import org.springframework.beans.factory.config.BeanPostProcessor;import org.springframework.stereotype.Component;@Componentpublic class TestBeanInit implements BeanPostProcessor &#123; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; return BeanPostProcessor.super.postProcessBeforeInitialization(bean, beanName); &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; return BeanPostProcessor.super.postProcessAfterInitialization(bean, beanName); &#125;&#125; 实现该接口后会在每个 Bean 初始化时都进行拦截，因此会传递当前初始化的 Bean。 12345678910111213import org.springframework.beans.factory.InitializingBean;import org.springframework.stereotype.Component;@Componentpublic class TestBeanInit implements InitializingBean &#123; private String name; @Override public void afterPropertiesSet() throws Exception &#123; name = &quot;123&quot;; &#125;&#125; 该接口只会在当前 Bean 初始化时执行。","categories":[{"name":"2024","slug":"2024","permalink":"https://casuallc.github.io/categories/2024/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://casuallc.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"学习","slug":"学习","permalink":"https://casuallc.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://casuallc.github.io/tags/Spring-Boot/"}],"author":"changqing"},{"title":"Hexo 使用","slug":"Hexo-使用","date":"2024-02-06T09:23:07.000Z","updated":"2024-02-08T04:14:18.560Z","comments":true,"path":"2024/02/06/Hexo-使用/","permalink":"https://casuallc.github.io/2024/02/06/Hexo-%E4%BD%BF%E7%94%A8/","excerpt":"使用 Hexo 搭建网站 这里只是记录一些关键点，具体操作步骤参考官网：https://hexo.io/ 创建新文章生成文章 1hexo new &#x27;title&#x27; 设置目录和标签通过 tags、categories 设置，如下 1234tags: - 教程categories:- 2024","text":"使用 Hexo 搭建网站 这里只是记录一些关键点，具体操作步骤参考官网：https://hexo.io/ 创建新文章生成文章 1hexo new &#x27;title&#x27; 设置目录和标签通过 tags、categories 设置，如下 1234tags: - 教程categories:- 2024 上传图片把图片放到 &#x2F;source&#x2F;imgs&#x2F; 下，通过如下方式引用： 1![window 桌面图片](/imgs/2024/20240205.jpg) // markdown 语法 编译成静态 HTML 文件 1hexo g 本地启动服务，预览结果 1hexo s 部署到 Github需要在 _config.yml 中配置 github 地址和推送分支信息然后依次执行以下命令： 123hexo cleanhexo ghexo d 其他知识点设置目录 二级及以下的标题为文章内右侧目录 categories 可以设置层级，依次在下方列出即可 tags 可以设置多个 首页只显示文章概览信息 在文章中添加 &lt;!-- more --&gt;，则改符号之后的内容会隐藏。","categories":[{"name":"2024","slug":"2024","permalink":"https://casuallc.github.io/categories/2024/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://casuallc.github.io/tags/%E6%95%99%E7%A8%8B/"}],"author":"changqing"},{"title":"测试文章","slug":"hello-world","date":"2023-02-06T09:23:07.000Z","updated":"2024-02-18T06:16:58.517Z","comments":true,"path":"2023/02/06/hello-world/","permalink":"https://casuallc.github.io/2023/02/06/hello-world/","excerpt":"Pulsar 异地容灾多集群部署这种方式利用了消息的异步复制功能。在两个数据中心分别部署独立的集群，然后通过配置建立两个集群间的消息复制通道，这样其中一个集群收到的消息都会通过异步的方式发送到另外一个集群。正常情况下，客户端可以通过一个集群实现消息的发布和订阅，另外一个集群只是作为备份。当提供服务的集群不可用时，客户端主动切换到备份集群。备份集群保存了之前集群的所有数据（由于是异步复制，最新消息可能有部分丢失），客户端就可以通过备份集群继续处理消息。同时，客户端发送到备份集群的消息会在之前集群恢复后发送到之前的集群。","text":"Pulsar 异地容灾多集群部署这种方式利用了消息的异步复制功能。在两个数据中心分别部署独立的集群，然后通过配置建立两个集群间的消息复制通道，这样其中一个集群收到的消息都会通过异步的方式发送到另外一个集群。正常情况下，客户端可以通过一个集群实现消息的发布和订阅，另外一个集群只是作为备份。当提供服务的集群不可用时，客户端主动切换到备份集群。备份集群保存了之前集群的所有数据（由于是异步复制，最新消息可能有部分丢失），客户端就可以通过备份集群继续处理消息。同时，客户端发送到备份集群的消息会在之前集群恢复后发送到之前的集群。 基于地区的数据副本保存策略这种方式利用了消息的同步复制功能。即在多个数据中心建立一个大集群，每个地区的计算节点收到消息后都会通过同步的方式发送到多个数据中心的存储节点，从而保证一条消息的多个副本分散在多个数据中心（ADMQ会根据存储节点的配置信息区分不同数据中心的节点，消息写入时就可以确保消息写入到多个数据中心的节点）。这样一个数据中心不可用时，客户端可以读取到存在其他数据中心的消息。这种方案能确保不会丢失消息，但是延迟会比第一种高一点。","categories":[],"tags":[],"author":"changqing"}],"categories":[{"name":"2024","slug":"2024","permalink":"https://casuallc.github.io/categories/2024/"}],"tags":[{"name":"做菜","slug":"做菜","permalink":"https://casuallc.github.io/tags/%E5%81%9A%E8%8F%9C/"},{"name":"生活","slug":"生活","permalink":"https://casuallc.github.io/tags/%E7%94%9F%E6%B4%BB/"},{"name":"教程","slug":"教程","permalink":"https://casuallc.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"工具","slug":"工具","permalink":"https://casuallc.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"学习","slug":"学习","permalink":"https://casuallc.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://casuallc.github.io/tags/Spring-Boot/"}]}