<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo 使用</title>
    <url>/2024/02/06/Hexo-%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="使用-Hexo-搭建网站"><a href="#使用-Hexo-搭建网站" class="headerlink" title="使用 Hexo 搭建网站"></a>使用 Hexo 搭建网站</h1><blockquote>
<p>这里只是记录一些关键点，具体操作步骤参考官网：<a href="https://hexo.io/">https://hexo.io/</a></p>
</blockquote>
<h1 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a>创建新文章</h1><p><strong>生成文章</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new &#x27;title&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>设置目录和标签</strong><br>通过 tags、categories 设置，如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">tags: </span><br><span class="line">- 教程</span><br><span class="line">categories:</span><br><span class="line">- 2024</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p><strong>上传图片</strong><br>把图片放到 &#x2F;source&#x2F;imgs&#x2F; 下，通过如下方式引用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![window 桌面图片](/imgs/2024/20240205.jpg)  // markdown 语法</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/2024/20240205.jpg" alt="window 桌面图片"></p>
<p><strong>编译成静态 HTML 文件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<p><strong>本地启动服务，预览结果</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<h1 id="部署到-Github"><a href="#部署到-Github" class="headerlink" title="部署到 Github"></a>部署到 Github</h1><p>需要在 _config.yml 中配置 github 地址和推送分支信息<br>然后依次执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<h1 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h1><p><strong>设置目录</strong></p>
<ul>
<li>二级及以下的标题为文章内右侧目录</li>
<li>categories 可以设置层级，依次在下方列出即可</li>
<li>tags 可以设置多个</li>
</ul>
<p><strong>首页只显示文章概览信息</strong></p>
<p>在文章中添加 <code>&lt;!-- more --&gt;</code>，则改符号之后的内容会隐藏。</p>
]]></content>
      <categories>
        <category>2024</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Bean 生命周期</title>
    <url>/2024/02/07/Spring-Bean-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h1 id="Spring-Bean-生命周期"><a href="#Spring-Bean-生命周期" class="headerlink" title="Spring Bean 生命周期"></a>Spring Bean 生命周期</h1><p>spring 在初始化时会通过注解或者配置文件初始化所有的 bean，在初始化过程中支持执行自定义的逻辑，比如加载配置等。<br>spring bean 的生命周期如下图所示：<br><img src="/imgs/2024/0207_spring-bean-life.png" alt="Spring Bean 生命周期"></p>
<span id="more"></span>

<p>其中 BeanPostProcessor 是对所有 Bean 进行拦截， InitializingBean 是对当前 Bean 进行拦截。所以如果需要在一个 Bean 初始化时做一些初始化的工作，则要实现 InitializingBean 接口。<br>示例如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBeanInit</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">return</span> BeanPostProcessor.<span class="built_in">super</span>.postProcessBeforeInitialization(bean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">return</span> BeanPostProcessor.<span class="built_in">super</span>.postProcessAfterInitialization(bean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现该接口后会在每个 Bean 初始化时都进行拦截，因此会传递当前初始化的 Bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBeanInit</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        name = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该接口只会在当前 Bean 初始化时执行。</p>
]]></content>
      <categories>
        <category>2024</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>学习</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>测试文章</title>
    <url>/2023/04/05/hello-world/</url>
    <content><![CDATA[<h2 id="Pulsar-异地容灾"><a href="#Pulsar-异地容灾" class="headerlink" title="Pulsar 异地容灾"></a>Pulsar 异地容灾</h2><h3 id="多集群部署"><a href="#多集群部署" class="headerlink" title="多集群部署"></a>多集群部署</h3><p>这种方式利用了消息的异步复制功能。<br>在两个数据中心分别部署独立的集群，然后通过配置建立两个集群间的消息复制通道，这样其中一个集群收到的消息都会通过异步的方式发送到另外一个集群。正常情况下，客户端可以通过一个集群实现消息的发布和订阅，另外一个集群只是作为备份。当提供服务的集群不可用时，客户端主动切换到备份集群。备份集群保存了之前集群的所有数据（由于是异步复制，最新消息可能有部分丢失），客户端就可以通过备份集群继续处理消息。同时，客户端发送到备份集群的消息会在之前集群恢复后发送到之前的集群。</p>
<span id="more"></span>

<h3 id="基于地区的数据副本保存策略"><a href="#基于地区的数据副本保存策略" class="headerlink" title="基于地区的数据副本保存策略"></a>基于地区的数据副本保存策略</h3><p>这种方式利用了消息的同步复制功能。<br>即在多个数据中心建立一个大集群，每个地区的计算节点收到消息后都会通过同步的方式发送到多个数据中心的存储节点，从而保证一条消息的多个副本分散在多个数据中心（ADMQ会根据存储节点的配置信息区分不同数据中心的节点，消息写入时就可以确保消息写入到多个数据中心的节点）。这样一个数据中心不可用时，客户端可以读取到存在其他数据中心的消息。<br>这种方案能确保不会丢失消息，但是延迟会比第一种高一点。</p>
]]></content>
  </entry>
  <entry>
    <title>基于 valine 和 leancloud 的评论系统</title>
    <url>/2024/02/08/%E5%9F%BA%E4%BA%8E-valine-%E5%92%8C-leancloud-%E7%9A%84%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h1><p>基于 hexo next 主题搭建博客后，测试了几种评论系统，像畅言、Gitalk 等都需要登陆后才能评论，实际用起来比较繁琐，而且评论的人基于安全的考虑也不会授权第三方评论系统获得自己的账号授权。</p>
<p>试想，一个偶然发现的网站，一个没怎么听到过的系统，怎么会允许获取自己的账号授权呢。</p>
<span id="more"></span>

<h1 id="leancloud-valine"><a href="#leancloud-valine" class="headerlink" title="leancloud &amp; valine"></a>leancloud &amp; valine</h1><p>leancloud 是一个云计算平台，可以在上边创建应用，然后通过 http 或者其他方式调用平台对外提供的接口。最重要的是，平台提供的接口调用和存储功能都免费！！！</p>
<p>而 valine 就是基于这一特性，在 hexo 主题中嵌入评论插件，用户提交评论时会发数据发送到 leancloud 对外开放的接口，从而实现保存评论信息。</p>
<p>而且，该插件不需要登录。这样评论本身就没有了限制，大家可以畅所欲言，比畅言更畅言。但这种方式对博主本身的安全性有一定的影响，比如恶意评论导致 leancloud 的接口频繁调用。</p>
<h1 id="接入方式"><a href="#接入方式" class="headerlink" title="接入方式"></a>接入方式</h1><p>下面是以 NexT(7.8.0) 为例进行接入说明。</p>
<h2 id="注册-leancloud"><a href="#注册-leancloud" class="headerlink" title="注册 leancloud"></a>注册 leancloud</h2><p>登录 <a href="https://console.leancloud.app/">leancloud</a> 注册账号。<br><img src="/imgs/2024/0208_leancloud_register.png" alt="账号注册"></p>
<p>注意一定要用国际版，国内版存在个人信息验证问题！！！</p>
<p>注册成功并登录后，需要邮箱验证。</p>
<p>验证成功后就可以创建自己的应用了，在首页点击：Create App<br><img src="/imgs/2024/0208_leancloud_create_app.png" alt="创建 app"></p>
<p>选择开发者模式<br><img src="/imgs/2024/0208_leancloud_create_app_dev.png" alt="选择开发者模式"></p>
<p>创建完成过后点【设置】查看 app id 等信息。<br><img src="/imgs/2024/0208_leancloud_app_setting.png" alt="获取 AppId 等信息"></p>
<p>图上标记的信息需要在下面 NexT 主题中配置。</p>
<h2 id="配置-NexT"><a href="#配置-NexT" class="headerlink" title="配置 NexT"></a>配置 NexT</h2><p>在 _config.yml 中找到评论相关配置，设置评论方式为 valine，然后设置 app id 等信息</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="comment"># Choose a comment system to be displayed by default.</span></span><br><span class="line">  <span class="comment"># Available values: changyan | disqus | disqusjs | gitalk | livere | valine</span></span><br><span class="line">  <span class="attr">active:</span> <span class="string">valine</span></span><br><span class="line"></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">appid:</span> <span class="string">xxxx</span> <span class="comment"># Your leancloud application appid</span></span><br><span class="line">  <span class="attr">appkey:</span> <span class="string">xxxx</span> <span class="comment"># Your leancloud application appkey</span></span><br><span class="line">  <span class="attr">serverURLs:</span> <span class="string">https://xxxx</span> <span class="comment"># 会往这个地址中发送数据</span></span><br></pre></td></tr></table></figure>

<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="/imgs/2024/0208_valine_comment.png" alt="评论"></p>
]]></content>
      <categories>
        <category>2024</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>工具</tag>
      </tags>
  </entry>
</search>
