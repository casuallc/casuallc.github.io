<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo 使用</title>
    <url>/2024/02/06/Hexo-%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="使用-Hexo-搭建网站"><a href="#使用-Hexo-搭建网站" class="headerlink" title="使用 Hexo 搭建网站"></a>使用 Hexo 搭建网站</h1><blockquote>
<p>这里只是记录一些关键点，具体操作步骤参考官网：<a href="https://hexo.io/">https://hexo.io/</a></p>
</blockquote>
<h1 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a>创建新文章</h1><p><strong>生成文章</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new &#x27;title&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>设置目录和标签</strong><br>通过 tags、categories 设置，如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">tags: </span><br><span class="line">- 教程</span><br><span class="line">categories:</span><br><span class="line">- 2024</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p><strong>上传图片</strong><br>把图片放到 &#x2F;source&#x2F;imgs&#x2F; 下，通过如下方式引用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![window 桌面图片](/imgs/2024/20240205.jpg)  // markdown 语法</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/2024/20240205.jpg" alt="window 桌面图片"></p>
<p><strong>编译成静态 HTML 文件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<p><strong>本地启动服务，预览结果</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<h1 id="部署到-Github"><a href="#部署到-Github" class="headerlink" title="部署到 Github"></a>部署到 Github</h1><p>需要在 _config.yml 中配置 github 地址和推送分支信息<br>然后依次执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<h1 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h1><p><strong>设置目录</strong></p>
<ul>
<li>二级及以下的标题为文章内右侧目录</li>
<li>categories 可以设置层级，依次在下方列出即可</li>
<li>tags 可以设置多个</li>
</ul>
<p><strong>首页只显示文章概览信息</strong></p>
<p>在文章中添加 <code>&lt;!-- more --&gt;</code>，则改符号之后的内容会隐藏。</p>
]]></content>
      <categories>
        <category>2024</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Bean 生命周期</title>
    <url>/2024/02/07/Spring-Bean-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h1 id="Spring-Bean-生命周期"><a href="#Spring-Bean-生命周期" class="headerlink" title="Spring Bean 生命周期"></a>Spring Bean 生命周期</h1><p>spring 在初始化时会通过注解或者配置文件初始化所有的 bean，在初始化过程中支持执行自定义的逻辑，比如加载配置等。<br>spring bean 的生命周期如下图所示：<br><img src="/imgs/2024/0207_spring-bean-life.png" alt="Spring Bean 生命周期"></p>
<span id="more"></span>

<p>其中 BeanPostProcessor 是对所有 Bean 进行拦截， InitializingBean 是对当前 Bean 进行拦截。所以如果需要在一个 Bean 初始化时做一些初始化的工作，则要实现 InitializingBean 接口。<br>示例如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBeanInit</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">return</span> BeanPostProcessor.<span class="built_in">super</span>.postProcessBeforeInitialization(bean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">return</span> BeanPostProcessor.<span class="built_in">super</span>.postProcessAfterInitialization(bean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现该接口后会在每个 Bean 初始化时都进行拦截，因此会传递当前初始化的 Bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBeanInit</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        name = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该接口只会在当前 Bean 初始化时执行。</p>
]]></content>
      <categories>
        <category>2024</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>学习</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>测试文章</title>
    <url>/2023/02/06/hello-world/</url>
    <content><![CDATA[<h2 id="Pulsar-异地容灾"><a href="#Pulsar-异地容灾" class="headerlink" title="Pulsar 异地容灾"></a>Pulsar 异地容灾</h2><h3 id="多集群部署"><a href="#多集群部署" class="headerlink" title="多集群部署"></a>多集群部署</h3><p>这种方式利用了消息的异步复制功能。<br>在两个数据中心分别部署独立的集群，然后通过配置建立两个集群间的消息复制通道，这样其中一个集群收到的消息都会通过异步的方式发送到另外一个集群。正常情况下，客户端可以通过一个集群实现消息的发布和订阅，另外一个集群只是作为备份。当提供服务的集群不可用时，客户端主动切换到备份集群。备份集群保存了之前集群的所有数据（由于是异步复制，最新消息可能有部分丢失），客户端就可以通过备份集群继续处理消息。同时，客户端发送到备份集群的消息会在之前集群恢复后发送到之前的集群。</p>
<span id="more"></span>

<h3 id="基于地区的数据副本保存策略"><a href="#基于地区的数据副本保存策略" class="headerlink" title="基于地区的数据副本保存策略"></a>基于地区的数据副本保存策略</h3><p>这种方式利用了消息的同步复制功能。<br>即在多个数据中心建立一个大集群，每个地区的计算节点收到消息后都会通过同步的方式发送到多个数据中心的存储节点，从而保证一条消息的多个副本分散在多个数据中心（ADMQ会根据存储节点的配置信息区分不同数据中心的节点，消息写入时就可以确保消息写入到多个数据中心的节点）。这样一个数据中心不可用时，客户端可以读取到存在其他数据中心的消息。<br>这种方案能确保不会丢失消息，但是延迟会比第一种高一点。</p>
]]></content>
  </entry>
  <entry>
    <title>基于 valine 和 leancloud 的评论系统</title>
    <url>/2024/02/08/%E5%9F%BA%E4%BA%8E-valine-%E5%92%8C-leancloud-%E7%9A%84%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h1><p>基于 hexo next 主题搭建博客后，测试了几种评论系统，像畅言、Gitalk 等都需要登陆后才能评论，实际用起来比较繁琐，而且评论的人基于安全的考虑也不会授权第三方评论系统获得自己的账号授权。</p>
<p>试想，一个偶然发现的网站，一个没怎么听到过的系统，怎么会允许获取自己的账号授权呢。</p>
<span id="more"></span>

<h1 id="leancloud-valine"><a href="#leancloud-valine" class="headerlink" title="leancloud &amp; valine"></a>leancloud &amp; valine</h1><p>leancloud 是一个云计算平台，可以在上边创建应用，然后通过 http 或者其他方式调用平台对外提供的接口。最重要的是，平台提供的接口调用和存储功能都免费！！！</p>
<p>而 valine 就是基于这一特性，在 hexo 主题中嵌入评论插件，用户提交评论时会发数据发送到 leancloud 对外开放的接口，从而实现保存评论信息。</p>
<p>而且，该插件不需要登录。这样评论本身就没有了限制，大家可以畅所欲言，比畅言更畅言。但这种方式对博主本身的安全性有一定的影响，比如恶意评论导致 leancloud 的接口频繁调用。</p>
<h1 id="接入方式"><a href="#接入方式" class="headerlink" title="接入方式"></a>接入方式</h1><p>下面是以 NexT(7.8.0) 为例进行接入说明。</p>
<h2 id="注册-leancloud"><a href="#注册-leancloud" class="headerlink" title="注册 leancloud"></a>注册 leancloud</h2><p>登录 <a href="https://console.leancloud.app/">leancloud</a> 注册账号。<br><img src="/imgs/2024/0208_leancloud_register.png" alt="账号注册"></p>
<p>注意一定要用国际版，国内版存在个人信息验证问题！！！</p>
<p>注册成功并登录后，需要邮箱验证。</p>
<p>验证成功后就可以创建自己的应用了，在首页点击：Create App<br><img src="/imgs/2024/0208_leancloud_create_app.png" alt="创建 app"></p>
<p>选择开发者模式<br><img src="/imgs/2024/0208_leancloud_create_app_dev.png" alt="选择开发者模式"></p>
<p>创建完成过后点【设置】查看 app id 等信息。<br><img src="/imgs/2024/0208_leancloud_app_setting.png" alt="获取 AppId 等信息"></p>
<p>图上标记的信息需要在下面 NexT 主题中配置。</p>
<h2 id="配置-NexT"><a href="#配置-NexT" class="headerlink" title="配置 NexT"></a>配置 NexT</h2><p>在 _config.yml 中找到评论相关配置，设置评论方式为 valine，然后设置 app id 等信息</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="comment"># Choose a comment system to be displayed by default.</span></span><br><span class="line">  <span class="comment"># Available values: changyan | disqus | disqusjs | gitalk | livere | valine</span></span><br><span class="line">  <span class="attr">active:</span> <span class="string">valine</span></span><br><span class="line"></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">appid:</span> <span class="string">xxxx</span> <span class="comment"># Your leancloud application appid</span></span><br><span class="line">  <span class="attr">appkey:</span> <span class="string">xxxx</span> <span class="comment"># Your leancloud application appkey</span></span><br><span class="line">  <span class="attr">serverURLs:</span> <span class="string">https://xxxx</span> <span class="comment"># 会往这个地址中发送数据</span></span><br></pre></td></tr></table></figure>

<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="/imgs/2024/0208_valine_comment.png" alt="评论"></p>
]]></content>
      <categories>
        <category>2024</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>rust 简单入门</title>
    <url>/2024/02/19/rust-%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="Rust-简介"><a href="#Rust-简介" class="headerlink" title="Rust 简介"></a>Rust 简介</h1><p>Rust 是由 Mozilla 主导开发的通用、编译型编程语言。设计准则为“安全、并发、实用”，支持函数式、并行式、过程式以及面向对象的程式设计风格。</p>
<p>Rust 是一种系统编程语言，通常用于构建快速可靠的软件，特别是在需要内存安全和线程安全至关重要的情况下，如操作系统、游戏引擎和Web浏览器。</p>
<span id="more"></span>

<p>Rust 的一些关键特性：</p>
<ul>
<li><p>无 GC：Rust 通过其所有权系统实现内存安全，该系统确保有效地管理内存而无需垃圾收集器。</p>
</li>
<li><p>零成本抽象：Rust 允许使用高级抽象而不产生运行时开销，使得编写既安全又高效的代码成为可能。</p>
</li>
<li><p>高并发：Rust 的所有权模型和类型系统在编译时防止数据竞争，确保线程安全，使开发人员可以放心地编写并发代码。</p>
</li>
<li><p>Cargo 包管理器：Rust 配备了 Cargo，一个强大的包管理器和构建系统，简化了管理依赖项和构建项目的过程。</p>
</li>
<li><p>社区驱动的开发：Rust 拥有一个充满活力和积极的社区，为其开发、文档和生态系统做出贡献。</p>
</li>
</ul>
<h1 id="简答使用"><a href="#简答使用" class="headerlink" title="简答使用"></a>简答使用</h1><blockquote>
<p>参考：<a href="https://doc.rust-lang.org/book/title-page.html">https://doc.rust-lang.org/book/title-page.html</a></p>
</blockquote>
<h2 id="安装（windows）"><a href="#安装（windows）" class="headerlink" title="安装（windows）"></a>安装（windows）</h2><p>到 <a href="https://www.rust-lang.org/tools/install">Rust 官网</a> 下载 Rust 安装器安装即可（可能需要先安装 Visual Studio）。</p>
<p>安装后打开 PowerShell 执行 rustc –version，如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\casua&gt; rustc <span class="literal">--version</span></span><br><span class="line">rustc <span class="number">1.75</span>.<span class="number">0</span> (<span class="number">82</span>e1608df <span class="number">2023</span><span class="literal">-12-21</span>)</span><br><span class="line"><span class="built_in">PS</span> C:\Users\casua&gt;</span><br></pre></td></tr></table></figure>

<p>有如上输出则证明安装成功，下面就可以编写测试代码进行功能测试了。</p>
<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>和其他编程语言一样，从 Hello World 开始了解 Rust。</p>
<p>首先我们需要创建一个文件夹：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mkdir rust<span class="literal">-test</span> </span><br></pre></td></tr></table></figure>

<p>然后创建 main.rs 文件，并写入如下代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译成可执行文件：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">powershell</span><br></pre></td></tr></table></figure>

<p>编译成功后会生成 main.exe 和 main.pbd 文件，exe 是可执行文件，pbd 是包含调试信息的中间文件。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">PS E:\rust-test&gt; ls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    目录: E:\rust-test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mode                 LastWriteTime         Length Name</span><br><span class="line">----                 -------------         ------ ----</span><br><span class="line">-a----         2024/2/19     15:12         148480 main.exe</span><br><span class="line">-a----         2024/2/19     15:12        1339392 main.pdb</span><br><span class="line">-a----         2024/2/19     15:11             42 main.rs</span><br></pre></td></tr></table></figure>

<p>执行：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> E:\rust<span class="literal">-test</span>&gt; ./main</span><br><span class="line">Hello World</span><br><span class="line"><span class="built_in">PS</span> E:\rust<span class="literal">-test</span>&gt;</span><br></pre></td></tr></table></figure>

<p>至此，我们第一个 rust 程序运行成功了。</p>
<h2 id="包管理工具-Cargo"><a href="#包管理工具-Cargo" class="headerlink" title="包管理工具 Cargo"></a>包管理工具 Cargo</h2><p>用 rustc 只能编译单个文件，如果是一个比较大的项目则需要使用 Cargo，Cargo 是一个包管理工具，可以管理和编译多个 Rust 文件。</p>
<p>Cargo 在安装 Rust 时已经默认安装了，所以我们可以直接使用。</p>
<p>首先创建一个工程：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> E:\rust<span class="literal">-test</span>&gt; cargo new hello</span><br><span class="line">     Created binary (application) `hello` package</span><br><span class="line"><span class="built_in">PS</span> E:\rust<span class="literal">-test</span>&gt; <span class="built_in">cd</span> .\hello\</span><br><span class="line"><span class="built_in">PS</span> E:\rust<span class="literal">-test</span>\hello&gt; <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    目录: E:\rust<span class="literal">-test</span>\hello</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mode                 LastWriteTime         Length Name</span><br><span class="line"><span class="literal">----</span>                 <span class="literal">-------------</span>         <span class="literal">------</span> <span class="literal">----</span></span><br><span class="line">d<span class="literal">-----</span>         <span class="number">2024</span>/<span class="number">2</span>/<span class="number">19</span>     <span class="number">15</span>:<span class="number">24</span>                src</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2024</span>/<span class="number">2</span>/<span class="number">19</span>     <span class="number">15</span>:<span class="number">24</span>              <span class="number">8</span> .gitignore</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2024</span>/<span class="number">2</span>/<span class="number">19</span>     <span class="number">15</span>:<span class="number">24</span>            <span class="number">174</span> Cargo.toml</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">PS</span> E:\rust<span class="literal">-test</span>\hello&gt;</span><br></pre></td></tr></table></figure>

<p>创建成功后会生成 Cargo.toml 文件，文件中记录了项目信息，包含版本、依赖等内容，如下：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[package]</span><br><span class="line">name = &quot;hello&quot;</span><br><span class="line">version = &quot;0.1.0&quot;</span><br><span class="line">edition = &quot;2021&quot;</span><br><span class="line"></span><br><span class="line"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span><br><span class="line"></span><br><span class="line">[dependencies]</span><br></pre></td></tr></table></figure>

<p>然后我们在 src 目录创建 main.rs，加上刚才测试的代码并使用 cargo 构建：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> E:\rust<span class="literal">-test</span>\hello&gt; cargo build</span><br><span class="line">   Compiling hello v0.<span class="number">1.0</span> (E:\rust<span class="literal">-test</span>\hello)</span><br><span class="line">    Finished dev <span class="function">[<span class="type">unoptimized</span> + <span class="type">debuginfo</span>] <span class="title">target</span></span>(s) <span class="keyword">in</span> <span class="number">0.51</span>s</span><br><span class="line"><span class="built_in">PS</span> E:\rust<span class="literal">-test</span>\hello&gt;</span><br></pre></td></tr></table></figure>

<p>构建成功后在 target&#x2F;debug 目录可以看到可执行文件 hello.exe：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> E:\rust<span class="literal">-test</span>\hello&gt; .\target\debug\hello.exe</span><br><span class="line">Hello World</span><br><span class="line"><span class="built_in">PS</span> E:\rust<span class="literal">-test</span>\hello&gt;</span><br></pre></td></tr></table></figure>

<p>我们还可以直接使用 cargo run 执行代码：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> E:\rust<span class="literal">-test</span>\hello&gt; cargo run</span><br><span class="line">    Finished dev <span class="function">[<span class="type">unoptimized</span> + <span class="type">debuginfo</span>] <span class="title">target</span></span>(s) <span class="keyword">in</span> <span class="number">0.00</span>s</span><br><span class="line">     Running `target\debug\hello.exe`</span><br><span class="line">Hello World</span><br><span class="line"><span class="built_in">PS</span> E:\rust<span class="literal">-test</span>\hello&gt;</span><br></pre></td></tr></table></figure>

<h1 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h1><p>Rust 没有垃圾回收，也不用像 C&#x2F;C++ 那样手动申请内存、释放内存。在 Rust 中，每个值在某个时刻都有唯一一个所有者，所有者发生改变后，该值就不能再次使用。</p>
<ul>
<li>Rust 中每个值都有一个 owner。</li>
<li>同一时刻只能有一个 owner。</li>
<li>当离开 owner 范围后，该值不能再次使用。</li>
</ul>
<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>举例如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">param</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  <span class="title function_ invoke__">owner_change</span>(param);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;value: &#123;&#125;&quot;</span>, param); <span class="comment">// 报错；param 的所有权已经转移到其他地方，因此这里不能再次使用了</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">owner_change</span>(v: <span class="type">String</span>) &#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;value in method: &#123;&#125;&quot;</span>, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> E:\rust<span class="literal">-test</span>\hello&gt; cargo run</span><br><span class="line">   Compiling hello v0.<span class="number">1.0</span> (E:\rust<span class="literal">-test</span>\hello)</span><br><span class="line">error[<span class="type">E0382</span>]: borrow of moved value: `param`</span><br><span class="line"> <span class="literal">--</span>&gt; src\main.rs:<span class="number">5</span>:<span class="number">25</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">2</span> |   let <span class="keyword">param</span> = String::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  |       <span class="literal">-----</span> <span class="built_in">move</span> occurs because `param` has <span class="built_in">type</span> `String`, which does not implement the `Copy` trait</span><br><span class="line"><span class="number">3</span> |   owner_change(<span class="keyword">param</span>);</span><br><span class="line">  |                <span class="literal">-----</span> value moved here</span><br><span class="line"><span class="number">4</span> |</span><br><span class="line"><span class="number">5</span> |   println!(<span class="string">&quot;value: &#123;&#125;&quot;</span>, <span class="keyword">param</span>); // 报错；<span class="keyword">param</span> 的所有权已经转移到其他地方，因此这里不能再次使用了</span><br><span class="line">      ...</span><br><span class="line">  |                         ^^^^^ value borrowed here after <span class="built_in">move</span></span><br><span class="line">  |</span><br><span class="line">note: consider changing this <span class="keyword">parameter</span> <span class="built_in">type</span> <span class="keyword">in</span> <span class="function"><span class="keyword">function</span> `<span class="title">owner_change</span>` <span class="title">to</span> <span class="title">borrow</span> <span class="title">instead</span> <span class="title">if</span> <span class="title">owning</span> <span class="title">the</span> <span class="title">value</span> <span class="title">isn</span>&#x27;<span class="title">t</span> <span class="title">necessary</span></span></span><br><span class="line"> <span class="literal">--</span>&gt; src\main.rs:<span class="number">9</span>:<span class="number">20</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">9</span> | fn owner_change(v: String) &#123;</span><br><span class="line">  |    <span class="literal">------------</span>    ^^^^^^ this <span class="keyword">parameter</span> takes ownership of the value</span><br><span class="line">  |    |</span><br><span class="line">  |    <span class="keyword">in</span> this <span class="function"><span class="keyword">function</span></span></span><br><span class="line">  = note: this error originates <span class="keyword">in</span> the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (<span class="keyword">in</span> Nightly builds, run with <span class="literal">-Z</span> macro<span class="literal">-backtrace</span> <span class="keyword">for</span> more info)</span><br><span class="line">help: consider cloning the value <span class="keyword">if</span> the performance cost is acceptable</span><br><span class="line">  |</span><br><span class="line"><span class="number">3</span> |   owner_change(param.clone());</span><br><span class="line">  |                     ++++++++</span><br><span class="line"></span><br><span class="line"><span class="keyword">For</span> more information about this error, <span class="keyword">try</span> `rustc <span class="literal">--explain</span> E0382`.</span><br><span class="line">error: could not compile `hello` (bin <span class="string">&quot;hello&quot;</span>) due to previous error</span><br><span class="line"><span class="built_in">PS</span> E:\rust<span class="literal">-test</span>\hello&gt;</span><br></pre></td></tr></table></figure>


<p>但我们可以在方法执行完再次获取到所有权，如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">param</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">param</span> = <span class="title function_ invoke__">owner_change</span>(param);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;value: &#123;&#125;&quot;</span>, param); <span class="comment">// 正常输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">owner_change</span>(v: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;value in method: &#123;&#125;&quot;</span>, v);</span><br><span class="line">  v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="变量传递"><a href="#变量传递" class="headerlink" title="变量传递"></a>变量传递</h2><p>同样，如果一个变量赋予另外一个变量，则之前的变量不能再次使用，如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br><span class="line">  <span class="title function_ invoke__">println</span>(<span class="string">&quot;s1: &#123;&#125;, s2: &#123;&#125;&quot;</span>, s1, s2); <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> E:\rust<span class="literal">-test</span>\hello&gt; cargo run</span><br><span class="line">   Compiling hello v0.<span class="number">1.0</span> (E:\rust<span class="literal">-test</span>\hello)</span><br><span class="line">error[<span class="type">E0382</span>]: borrow of moved value: `s1`</span><br><span class="line"> <span class="literal">--</span>&gt; src\main.rs:<span class="number">4</span>:<span class="number">30</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">2</span> |   let s1 = String::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  |       <span class="literal">--</span> <span class="built_in">move</span> occurs because `s1` has <span class="built_in">type</span> `String`, which does not implement the `Copy` trait</span><br><span class="line"><span class="number">3</span> |   let s2 = s1;</span><br><span class="line">  |            <span class="literal">--</span> value moved here</span><br><span class="line"><span class="number">4</span> |   println!(<span class="string">&quot;s1: &#123;&#125;, s2: &#123;&#125;&quot;</span>, s1, s2);</span><br><span class="line">  |                              ^^ value borrowed here after <span class="built_in">move</span></span><br><span class="line">  |</span><br><span class="line">  = note: this error originates <span class="keyword">in</span> the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (<span class="keyword">in</span> Nightly builds, run with <span class="literal">-Z</span> macro<span class="literal">-backtrace</span> <span class="keyword">for</span> more info)</span><br><span class="line">help: consider cloning the value <span class="keyword">if</span> the performance cost is acceptable</span><br><span class="line">  |</span><br><span class="line"><span class="number">3</span> |   let s2 = s1.clone();</span><br><span class="line">  |              ++++++++</span><br><span class="line"></span><br><span class="line"><span class="keyword">For</span> more information about this error, <span class="keyword">try</span> `rustc <span class="literal">--explain</span> E0382`.</span><br><span class="line">error: could not compile `hello` (bin <span class="string">&quot;hello&quot;</span>) due to previous error</span><br><span class="line"><span class="built_in">PS</span> E:\rust<span class="literal">-test</span>\hello&gt;</span><br></pre></td></tr></table></figure>

<h2 id="传递地址"><a href="#传递地址" class="headerlink" title="传递地址"></a>传递地址</h2><p>在方法中传递引用所有权会发生改变，传递地址所有权不会发生改变，因此如下代码可以正常运行：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">param</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">owner_change</span>(&amp;param);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;value: &#123;&#125;, len: &#123;&#125;&quot;</span>, param, len);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">owner_change</span>(v: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;value in method: &#123;&#125;&quot;</span>, v);</span><br><span class="line">  v.<span class="title function_ invoke__">len</span>() <span class="comment">// 非分号结尾表示返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> E:\rust<span class="literal">-test</span>\hello&gt; cargo run</span><br><span class="line">   Compiling hello v0.<span class="number">1.0</span> (E:\rust<span class="literal">-test</span>\hello)</span><br><span class="line">    Finished dev <span class="function">[<span class="type">unoptimized</span> + <span class="type">debuginfo</span>] <span class="title">target</span></span>(s) <span class="keyword">in</span> <span class="number">0.29</span>s</span><br><span class="line">     Running `target\debug\hello.exe`</span><br><span class="line">value <span class="keyword">in</span> method: hello</span><br><span class="line">value: hello, len: <span class="number">5</span></span><br><span class="line"><span class="built_in">PS</span> E:\rust<span class="literal">-test</span>\hello&gt;</span><br></pre></td></tr></table></figure>

<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>上面体验了下 Rust 的基本用法，主要是所有权这块。Rust 在编译时强制用户按照约定的规则编写代码，增加了代码编写难度。一旦编译成功，则基本不可能出现内存泄漏问题。</p>
]]></content>
      <categories>
        <category>2024</category>
      </categories>
  </entry>
  <entry>
    <title>地三鲜家常做法</title>
    <url>/2024/02/14/%E5%9C%B0%E4%B8%89%E9%B2%9C%E5%AE%B6%E5%B8%B8%E5%81%9A%E6%B3%95/</url>
    <content><![CDATA[<h1 id="地三鲜家常做法"><a href="#地三鲜家常做法" class="headerlink" title="地三鲜家常做法"></a>地三鲜家常做法</h1><p>过年闲来无事，研究一些家常菜，也满足下自己的胃。</p>
<p>首先是地三鲜，这个相对来说很简单，而且材料只需要土豆、茄子和青椒。</p>
<span id="more"></span>
<h1 id="材料准备"><a href="#材料准备" class="headerlink" title="材料准备"></a>材料准备</h1><p>茄子、土豆切块，青椒用手撕成小块，然后茄子撒上淀粉，用手抓匀，确保每个茄子上都有一层淀粉。</p>
<p>调料</p>
<ul>
<li>盐</li>
<li>生抽</li>
<li>老抽</li>
<li>鸡精</li>
<li>耗油</li>
<li>糖</li>
<li>葱姜蒜</li>
<li>玉米淀粉</li>
</ul>
<h1 id="准备料汁"><a href="#准备料汁" class="headerlink" title="准备料汁"></a>准备料汁</h1><p>碗中添加盐、生抽、老抽、鸡精、糖、淀粉，加水拌匀。</p>
<h1 id="油炸"><a href="#油炸" class="headerlink" title="油炸"></a>油炸</h1><p>锅中烧油，六成热后放入土豆、青椒，土豆炸出金黄捞出。</p>
<p>继续放入茄子，变色后再炸一会捞出。</p>
<h1 id="炒"><a href="#炒" class="headerlink" title="炒"></a>炒</h1><p>锅中油倒出，留一点准备炒菜。放入葱姜蒜，炒出蒜香。</p>
<p>然后加入炸后的土豆、青椒和茄子，用铲子炒一会后放入准备好的调料，继续翻炒一会即可装盘捞出。</p>
]]></content>
      <categories>
        <category>2024</category>
      </categories>
      <tags>
        <tag>做菜</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>番茄土豆肥牛</title>
    <url>/2024/02/14/%E7%95%AA%E8%8C%84%E5%9C%9F%E8%B1%86%E8%82%A5%E7%89%9B/</url>
    <content><![CDATA[<h1 id="番茄土豆肥牛做法"><a href="#番茄土豆肥牛做法" class="headerlink" title="番茄土豆肥牛做法"></a>番茄土豆肥牛做法</h1><p>分享一道简单好吃的家常菜：番茄土豆肥牛。</p>
<span id="more"></span>

<h1 id="材料准备"><a href="#材料准备" class="headerlink" title="材料准备"></a>材料准备</h1><p>主要是牛肉卷和番茄，其他都是看心情添加。我们是吃火锅剩了一些牛肉，所以第二天做了这道番茄肥牛，虽然看起来不怎么样，但吃起来还可以。需要准备的菜和调料如下：</p>
<ul>
<li>番茄</li>
<li>土豆</li>
<li>牛肉卷</li>
<li>牛肉丸（可选）</li>
<li>金针菇</li>
<li>娃娃菜</li>
<li>小葱</li>
<li>盐</li>
<li>葱姜蒜</li>
<li>老抽</li>
<li>生抽</li>
<li>耗油</li>
<li>白醋</li>
<li>番茄酱</li>
<li>淀粉</li>
</ul>
<p>土豆和番茄切丁，番茄需要先用开水去皮。</p>
<h1 id="调汁"><a href="#调汁" class="headerlink" title="调汁"></a>调汁</h1><p>万众放入适量盐、老抽、生抽、耗油、淀粉，加水搅拌均匀。</p>
<h1 id="把牛肉、金针菇煮熟"><a href="#把牛肉、金针菇煮熟" class="headerlink" title="把牛肉、金针菇煮熟"></a>把牛肉、金针菇煮熟</h1><p>锅中烧水，先放入金针菇，几分钟后捞出备用。</p>
<p>然后放入土豆，煮熟后捞出。</p>
<p>最后放入牛肉和牛肉丸，加入少许白醋去腥，等牛肉变色后捞出。</p>
<h1 id="炒"><a href="#炒" class="headerlink" title="炒"></a>炒</h1><p>锅中烧油，加入葱姜蒜，炒出蒜香后加番茄翻炒，把番茄炒成番茄汁，然后加入刚才调好的酱汁，继续翻炒几下加入少许番茄酱提味。</p>
<p>然后加入适量水，水开后加入金针菇、土豆、牛肉和牛肉丸，煮几分钟等菜入味后装盘即可。</p>
]]></content>
      <categories>
        <category>2024</category>
      </categories>
      <tags>
        <tag>做菜</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 配置加载流程</title>
    <url>/2024/03/08/Spring-Boot-%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="配置文件加载方式"><a href="#配置文件加载方式" class="headerlink" title="配置文件加载方式"></a>配置文件加载方式</h1><h2 id="常见配置位置"><a href="#常见配置位置" class="headerlink" title="常见配置位置"></a>常见配置位置</h2><ol>
<li>config 目录</li>
<li>当前目录</li>
<li>classpath 下的 config 目录</li>
<li>classpath 目录</li>
</ol>
<p>高优先级的配置会覆盖低优先级的配置。</p>
<h2 id="完整的配置加载顺序"><a href="#完整的配置加载顺序" class="headerlink" title="完整的配置加载顺序"></a>完整的配置加载顺序</h2><p><strong>Devtools global settings properties on your home directory (~&#x2F;.spring-boot-devtools.properties when devtools is active).</strong></p>
<p>可以在服务器 home 目录放置配置文件：.spring-boot-devtools.properties，该文件中的配置对服务器上的所有 spring boot 项目都生效。</p>
<span id="more"></span>

<p><strong>@TestPropertySource annotations on your tests.</strong></p>
<p><strong>properties attribute on your tests. Available on @SpringBootTest and the test annotations for testing a particular slice of your application.</strong></p>
<p><strong>Command line arguments.</strong></p>
<p>命令行中传递的参数，例如：java -jar xxx.jar –server.port&#x3D;9000</p>
<p>如果要禁用命令行传递参数，则设置 <code>SpringApplication.setAddCommandLineProperties(false)</code></p>
<p><strong>Properties from SPRING_APPLICATION_JSON (inline JSON embedded in an environment variable or system property).</strong></p>
<p>通过设置环境变量或者命令行传递参数的方式使配置生效。<br>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方式一：</span><br><span class="line">SPRING_APPLICATION_JSON=&#x27;&#123;&quot;acme&quot;:&#123;&quot;name&quot;:&quot;test&quot;&#125;&#125;&#x27; java -jar myapp.jar</span><br><span class="line"></span><br><span class="line">方式二：</span><br><span class="line">java -Dspring.application.json=&#x27;&#123;&quot;name&quot;:&quot;test&quot;&#125;&#x27; -jar myapp.jar</span><br><span class="line"></span><br><span class="line">方式三：</span><br><span class="line">java -jar myapp.jar --spring.application.json=&#x27;&#123;&quot;name&quot;:&quot;test&quot;&#125;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>ServletConfig init parameters.</strong></p>
<p><strong>ServletContext init parameters.</strong></p>
<p><strong>JNDI attributes from java:comp&#x2F;env.</strong></p>
<p><strong>Java System properties (System.getProperties()).</strong></p>
<p><strong>OS environment variables.</strong></p>
<p><strong>A RandomValuePropertySource that has properties only in random.*.</strong></p>
<p>如果需要设置动态密码等配置，可以在配置文件中使用 random，例如：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">my.secret</span>=<span class="string">$&#123;random.value&#125;</span></span><br><span class="line"><span class="attr">my.number</span>=<span class="string">$&#123;random.int&#125;</span></span><br><span class="line"><span class="attr">my.bignumber</span>=<span class="string">$&#123;random.long&#125;</span></span><br><span class="line"><span class="attr">my.uuid</span>=<span class="string">$&#123;random.uuid&#125;</span></span><br><span class="line"><span class="attr">my.number.less.than.ten</span>=<span class="string">$&#123;random.int(10)&#125;</span></span><br><span class="line"><span class="attr">my.number.in.range</span>=<span class="string">$&#123;random.int[1024,65536]&#125;</span></span><br></pre></td></tr></table></figure>

<p>此类参数的解析类是：RandomValuePropertySource </p>
<p><strong>Profile-specific application properties outside of your packaged jar (application-{profile}.properties and YAML variants).</strong></p>
<p>jar 包外的 application-{profile}.properties、yaml 文件。</p>
<p><strong>Profile-specific application properties packaged inside your jar (application-{profile}.properties and YAML variants).</strong></p>
<p>jar 包内的 application-{profile}.properties、yaml 文件。</p>
<p>profile 即启动程序指定的配置：<code>spring.profiles.active</code> 指定的内容。需要特别说明的是，如果使用 <code>spring.config.location</code> 指定了具体的文件，则 <code>spring.profiles.active</code> 不再生效。</p>
<p>如果要同时支持两个，则需要用 <code>spring.config.location</code> 指定目录。</p>
<p><strong>Application properties outside of your packaged jar (application.properties and YAML variants).</strong></p>
<p>jar 包内的 application.properties 文件。</p>
<p><strong>Application properties packaged inside your jar (application.properties and YAML variants).</strong></p>
<p>jar 包外的 application.properties 文件。</p>
<p><em><em>@PropertySource annotations on your @Configuration classes. Please note that such property sources are not added to the Environment until the application context is being refreshed. This is too late to configure certain properties such as logging.</em> and spring.main.</em> which are read before refresh begins.**</p>
<p><strong>Default properties (specified by setting SpringApplication.setDefaultProperties).</strong></p>
<h2 id="引用配置文件中已有的配置"><a href="#引用配置文件中已有的配置" class="headerlink" title="引用配置文件中已有的配置"></a>引用配置文件中已有的配置</h2><p>如果配置文件中有很多相似的配置，则可以使用占位符的方式在后面的配置中引用前面已经配置过的配置项。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">app.name=MyApp</span><br><span class="line">app.description=$&#123;app.name&#125; is a Spring Boot application.</span><br></pre></td></tr></table></figure>

<h2 id="在应用启动前自定义配置处理器"><a href="#在应用启动前自定义配置处理器" class="headerlink" title="在应用启动前自定义配置处理器"></a>在应用启动前自定义配置处理器</h2><p>Spring Boot 没有内置任何加密方法，但是可以利用 <code>EnvironmentPostProcessor </code> 简介实现该功能，也可以使用 Spring Cloud Vault 功能。</p>
<p>在 SpringApplication 启动前可以添加自己的监听器，在监听器中处理配置等功能。</p>
<p>Spring Boot 从 META-INF&#x2F;spring.factories 中加载一些自定义的监听器并执行，这里有几种方式注册监听器：</p>
<ul>
<li>在 SpringApplication 中调用 addListeners 和 addInitializers，<code>new SpringApplicationBuilder(CRMApplication.class).listeners(null).run(args);</code></li>
<li>设置 context.initializer.classes 或者 context.listener.classes 属性</li>
<li>在 META-INF&#x2F;spring.factories 中添加，并作为一个 jar 包被引入其他应用中。</li>
</ul>
<p>实现 EnvironmentPostProcessor 接口并加载，然后就可以加载新的配置或者修改配置，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnvironmentPostProcessorExample</span> <span class="keyword">implements</span> <span class="title class_">EnvironmentPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">YamlPropertySourceLoader</span> <span class="variable">loader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">YamlPropertySourceLoader</span>();</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessEnvironment</span><span class="params">(ConfigurableEnvironment environment, SpringApplication application)</span> &#123;</span><br><span class="line">		<span class="type">Resource</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;com/example/myapp/config.yml&quot;</span>);</span><br><span class="line">		PropertySource&lt;?&gt; propertySource = loadYaml(path);</span><br><span class="line">		environment.getPropertySources().addLast(propertySource);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> PropertySource&lt;?&gt; loadYaml(Resource path) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!path.exists()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Resource &quot;</span> + path + <span class="string">&quot; does not exist&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">this</span>.loader.load(<span class="string">&quot;custom-resource&quot;</span>, path).get(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Failed to load yaml configuration from &quot;</span> + path, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="配置便捷注入"><a href="#配置便捷注入" class="headerlink" title="配置便捷注入"></a>配置便捷注入</h2><p>通常在代码中使用 <code>@Value(&quot;$&#123;property.name&#125;&quot;)</code> 注入配置内容，如果很多配置具有相同的前缀，则可以使用 <code>ConfigurationProperties</code> 注入，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;acme&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AcmeProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="type">boolean</span> enabled;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> InetAddress remoteAddress;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Security</span> <span class="variable">security</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Security</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEnabled</span><span class="params">(<span class="type">boolean</span> enabled)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> InetAddress <span class="title function_">getRemoteAddress</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRemoteAddress</span><span class="params">(InetAddress remoteAddress)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Security <span class="title function_">getSecurity</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Security</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> List&lt;String&gt; roles = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Collections.singleton(<span class="string">&quot;USER&quot;</span>));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassword</span><span class="params">(String password)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getRoles</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoles</span><span class="params">(List&lt;String&gt; roles)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件中的配置项如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># with a value of false by default.</span></span><br><span class="line"><span class="attr">acme.enabled</span>=<span class="string">false </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># with a type that can be coerced from String.</span></span><br><span class="line"><span class="attr">acme.remote-address</span>=<span class="string">1.1.1.1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># with a nested &quot;security&quot; object whose name is determined by the name of the property. In particular, the return type is not used at all there and could have been SecurityProperties.</span></span><br><span class="line"><span class="attr">acme.security.username</span>=<span class="string">name</span></span><br><span class="line"></span><br><span class="line"><span class="attr">acme.security.password</span>=<span class="string">pwd</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># with a collection of String.</span></span><br><span class="line"><span class="attr">acme.security.roles</span>=<span class="string">role1,role2</span></span><br></pre></td></tr></table></figure>

<p>同时还需要主动注册上边的配置类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(AcmeProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfiguration</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://docs.spring.io/spring-boot/docs/2.1.13.RELEASE/reference/html/boot-features-external-config.html">https://docs.spring.io/spring-boot/docs/2.1.13.RELEASE/reference/html/boot-features-external-config.html</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.1.13.RELEASE/reference/html/using-boot-devtools.html#using-boot-devtools-globalsettings">https://docs.spring.io/spring-boot/docs/2.1.13.RELEASE/reference/html/using-boot-devtools.html#using-boot-devtools-globalsettings</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.1.13.RELEASE/reference/html/howto-spring-boot-application.html#howto-customize-the-environment-or-application-context">https://docs.spring.io/spring-boot/docs/2.1.13.RELEASE/reference/html/howto-spring-boot-application.html#howto-customize-the-environment-or-application-context</a></li>
</ol>
]]></content>
      <categories>
        <category>2024</category>
      </categories>
  </entry>
</search>
